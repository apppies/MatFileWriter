{"version":3,"sources":["../src/matFileWriter.ts"],"sourcesContent":["import {zlibSync} from \"fflate\"\n\ntype TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | BigInt64Array | BigUint64Array | Uint8ClampedArray | Float32Array | Float64Array;\n\nenum DataTypes {\n    UNDEFINED = 0, //\n    miINT8 = 1, // 8 bit, signed\n    miUINT8 = 2, // 8 bit, unsigned\n    miINT16 = 3, // 16-bit, signed\n    miUINT16 = 4, // 16-bit, unsigned\n    miINT32 = 5, // 32-bit, signed\n    miUINT32 = 6, // 32-bit, unsigned\n    miSINGLE = 7, // IEEE® 754 single format\n    miRESERVED1 = 8, // Reserved\n    miDOUBLE = 9, // IEEE 754 double format\n    miRESERVED2 = 10, // Reserved\n    miRESERVED3 = 11, // Reserved\n    miINT64 = 12, // 64-bit, signed\n    miUINT64 = 13, // 64-bit, unsigned\n    miMATRIX = 14, // MATLAB array\n    miCOMPRESSED = 15, // Compressed Data\n    miUTF8 = 16, // Unicode UTF-8 Encoded Character Data\n    miUTF16 = 17, // Unicode UTF-16 Encoded Character Data\n    miUTF32 = 18, // Unicode UTF-32 Encoded Character Data\n}\n\nenum ArrayTypes {\n    mxCELL_CLASS = 1, // Cell array \n    mxSTRUCT_CLASS = 2, // Structure \n    mxOBJECT_CLASS = 3, // Object \n    mxCHAR_CLASS = 4, // Character array \n    mxSPARSE_CLASS = 5, // Sparse array \n    mxDOUBLE_CLASS = 6, // Double precision array \n    mxSINGLE_CLASS = 7, // Single precision array \n    mxINT8_CLASS = 8, // 8-bit, signed integer \n    mxUINT8_CLASS = 9, // 8-bit, unsigned integer \n    mxINT16_CLASS = 10, // 16-bit, signed integer \n    mxUINT16_CLASS = 11, // 16-bit, unsigned integer \n    mxINT32_CLASS = 12, // 32-bit, signed integer \n    mxUINT32_CLASS = 13, // 32-bit, unsigned integer \n    mxINT64_CLASS = 14, // 64-bit, signed integer \n    mxUINT64_CLASS = 15, // 64-bit, unsigned integer \n}\n\nexport class MatFileWriter {\n\n    private matFile: TypedArray[] = [];\n    constructor() {\n        this.matFile = [];\n        this.matFile.push(...this.createMatFileHeader());\n    }\n\n    \n    private compressionEnabled : boolean = true;\n    public get Compression() : boolean {\n        return this.compressionEnabled;\n    }\n    public set Compression(v : boolean) {\n        this.compressionEnabled = v;\n    }\n    \n\n    /**\n     * Add variable with given name and value to the current matlab file\n     * @param name Variable name\n     * @param value Variable data\n     */\n    public addVariable(name: string, value: any) {\n        this.matFile.push(...this.createMatArray(value, name, true));\n    }\n\n    private sizeOfDataType(dataType: DataTypes): number {\n        switch (dataType) {\n            case DataTypes.miINT8:\n            case DataTypes.miUINT8:\n                return 1;\n\n            case DataTypes.miINT16:\n            case DataTypes.miUINT16:\n                return 2;\n\n            case DataTypes.miSINGLE:\n            case DataTypes.miINT32:\n            case DataTypes.miUINT32:\n                return 4;\n\n            case DataTypes.miDOUBLE:\n            case DataTypes.miINT64:\n            case DataTypes.miUINT64:\n                return 8;\n\n            default:\n                break;\n        }\n        return 0;\n    }\n\n    private createMatFileHeader(): TypedArray[] {\n        let headerText = new Uint8Array(116);\n        let headerSubsystem = new Uint8Array(8);\n        let headerVersion = new Uint16Array(2);\n\n        const datetimeString = new Date().toISOString();\n        let text = `MATLAB 5.0 MAT-file, Created using MatFileWriter on ${datetimeString}`; // limit to 116 characters\n        Array.from(text).forEach((v, i) => headerText[i] = v.charCodeAt(0));\n        // Version\n        headerVersion[0] = 0x0100;\n        // For endianness write MI\n        headerVersion[1] = 0x4D49\n\n        return [headerText, headerSubsystem, headerVersion];\n    }\n\n    private getMatDataTypeFromTypedArray(typedArray: TypedArray): DataTypes {\n        let dataType: DataTypes;\n        switch (typedArray.constructor.name) {\n            case \"Int8Array\":\n                dataType = DataTypes.miINT8;\n                break;\n            case \"Uint8Array\":\n                dataType = DataTypes.miUINT8;\n                break;\n            case \"Int16Array\":\n                dataType = DataTypes.miINT16;\n                break;\n            case \"Uint16Array\":\n                dataType = DataTypes.miUINT16;\n                break;\n            case \"Int32Array\":\n                dataType = DataTypes.miINT32;\n                break;\n            case \"Uint32Array\":\n                dataType = DataTypes.miUINT32;\n                break;\n            case \"BigInt64Array\":\n                dataType = DataTypes.miINT64;\n                break;\n            case \"BigUint64Array\":\n                dataType = DataTypes.miUINT64;\n                break;\n            case \"Float32Array\":\n                dataType = DataTypes.miSINGLE;\n                break;\n            case \"Float64Array\":\n            default:\n                dataType = DataTypes.miDOUBLE;\n                break;\n        }\n        return dataType;\n    }\n\n    private getMatArrayTypeFromTypedArray(typedArray: TypedArray): ArrayTypes {\n        let dataType: ArrayTypes;\n        switch (typedArray.constructor.name) {\n            case \"Int8Array\":\n                dataType = ArrayTypes.mxINT8_CLASS;\n                break;\n            case \"Uint8Array\":\n                dataType = ArrayTypes.mxUINT8_CLASS;\n                break;\n            case \"Int16Array\":\n                dataType = ArrayTypes.mxINT16_CLASS;\n                break;\n            case \"Uint16Array\":\n                dataType = ArrayTypes.mxUINT16_CLASS;\n                break;\n            case \"Int32Array\":\n                dataType = ArrayTypes.mxINT32_CLASS;\n                break;\n            case \"Uint32Array\":\n                dataType = ArrayTypes.mxUINT32_CLASS;\n                break;\n            case \"BigInt64Array\":\n                dataType = ArrayTypes.mxINT64_CLASS;\n                break;\n            case \"BigUint64Array\":\n                dataType = ArrayTypes.mxUINT64_CLASS;\n                 break;\n            case \"Float32Array\":\n                dataType = ArrayTypes.mxSINGLE_CLASS;\n                break;\n            case \"Float64Array\":\n            default:\n                dataType = ArrayTypes.mxDOUBLE_CLASS;\n                break;\n        }\n        return dataType;\n    }\n\n    /**\n     * Put the data in a Data element object\n     * Determines datatype based on class of first typedarray by default, can be overruled\n     * @param dataType \n     * @param data \n     * @returns \n     */\n    private createDataElementFromTypedArray(data: TypedArray | TypedArray[], dataType: DataTypes = DataTypes.UNDEFINED): TypedArray[] {\n        if (!Array.isArray(data)) {\n            // Encapsulate in an array as that is what is used for the remainder of this function\n            data = [data];\n        }\n\n        if (dataType == DataTypes.UNDEFINED) {\n            // Auto determine the data type\n            dataType = this.getMatDataTypeFromTypedArray(data[0]);\n        }\n\n        let totalDataByteLength = data.reduce((sum, element) => sum + element.byteLength, 0);\n\n        let tag: TypedArray;\n        if (totalDataByteLength > 0 && totalDataByteLength <= 4) {\n            // Compact format possible\n            tag = new Uint16Array(2)\n            tag[0] = dataType;\n            tag[1] = totalDataByteLength;\n        } else {\n            tag = new Uint32Array(2)\n            tag[0] = dataType;\n            tag[1] = totalDataByteLength;\n        }\n\n        // Pad data to align with 8 bytes / 64 bits\n        let totalByteLength = tag.byteLength + totalDataByteLength;\n        let next8Byte = Math.ceil(totalByteLength / 8.0) * 8;\n        let padding = new Uint8Array(next8Byte - totalByteLength);\n        return [tag, ...data, padding];\n    }\n\n    private createDataElementFromNumbers(dataType: DataTypes, values: number[]): TypedArray[] {\n        if (!Array.isArray(values)) {\n            // Encapsulate in an array as that is what is used for the remainder of this function\n            values = [values];\n        }\n\n        // Create typed array with values\n        let data: TypedArray;\n        switch (dataType) {\n            case DataTypes.miINT8:\n                data = new Int8Array(values.length);\n                break;\n            case DataTypes.miUINT8:\n                data = new Uint8Array(values.length);\n                break;\n            case DataTypes.miINT16:\n                data = new Int16Array(values.length);\n                break;\n            case DataTypes.miUINT16:\n                data = new Uint16Array(values.length);\n                break;\n            case DataTypes.miINT32:\n                data = new Int32Array(values.length);\n                break;\n            case DataTypes.miUINT32:\n                data = new Uint32Array(values.length);\n                break;\n            case DataTypes.miINT64:\n                data = new BigInt64Array(values.length);\n                break;\n            case DataTypes.miUINT64:\n                data = new BigUint64Array(values.length);\n                break;\n            case DataTypes.miSINGLE:\n                data = new Float32Array(values.length);\n                break;\n            case DataTypes.miDOUBLE:\n            default:\n                data = new Float64Array(values.length);\n                break;\n        }\n        values.forEach((v, i) => data[i] = v);\n\n        return this.createDataElementFromTypedArray(data, dataType);\n    }\n\n    private stringToUtf8(str: string): Uint8Array {\n        let t = new TextEncoder()\n        return t.encode(str);\n    }\n\n    // Determine the smallest data type that fits all numbers\n    private getSmallestDataType(values: number[]): DataTypes {\n        let min = 0;\n        let max = 0;\n        let isInteger = true;\n        let isNumber = false;\n        values.forEach((v) => {\n            if (typeof (v) == 'number') {\n                isNumber = true;\n                if (v < min) min = v;\n                if (v > max) max = v;\n                if (isInteger) isInteger = Number.isInteger(v);\n            }\n        })\n\n        if (isNumber == false) {\n            // No numbers were found\n            return DataTypes.miDOUBLE;\n        }\n\n        let absMin = Math.min(Math.abs(min), max);\n        let absMax = Math.max(Math.abs(min), max);\n\n        let dataType = DataTypes.miDOUBLE; // Default to double        \n        if (isInteger) {\n            if (min == 0 && absMax <= 255) dataType = DataTypes.miUINT8;\n            else if (min >= -128 && max <= 127) dataType = DataTypes.miINT8;\n            else if (min == 0 && absMax <= 65535) dataType = DataTypes.miUINT16;\n            else if (min >= -32768 && max <= 32767) dataType = DataTypes.miINT16;\n            else if (min == 0 && absMax <= 4294967295) dataType = DataTypes.miUINT32;\n            else if (min >= -2147483648 && max <= 2147483647) dataType = DataTypes.miINT32;\n        } else {\n            // Dont use singles, they have less precision. We should check for each number if digits are used than don´t fit in a single\n            // But that is quite some work, so default to doubles \n            // if (absMin >= 1.1755e-38 && absMax <= 3.4028e+38) dataType = MatDataTypes.miSINGLE;\n            dataType = DataTypes.miDOUBLE;\n        }\n\n        return dataType;\n    }\n\n    /**\n     * Creates a matrix containing numbers.\n     * Only accepts 1-D arrays\n     * Assumes numbers are to be represented as doubles\n     * Might use a smaller range when possible for saving\n     */\n    private createNumericArray(name: string, realValues: number[] | TypedArray, complexValues: number[] = []): TypedArray[] {\n        let matrix: TypedArray[] = [];\n        let tag = new Uint32Array(2);\n        tag[0] = DataTypes.miMATRIX;\n        // tag[1] = number of bytes in matrix, to be set at end once all parts are in\n        matrix.push(tag);\n\n        const _flags = 0;\n        let _class = ArrayTypes.mxDOUBLE_CLASS;\n        if (this.isTypedArray(realValues)) {\n            _class = this.getMatArrayTypeFromTypedArray(realValues);\n        }\n        \n        let arrayFlags = this.createDataElementFromNumbers(DataTypes.miUINT32, [(_flags << 8) + _class, 0x00000000]); // 0xEFBEADDE\n        matrix.push(...arrayFlags);\n\n        let dimensionArray = this.createDataElementFromNumbers(DataTypes.miINT32, [1, realValues.length]);\n        matrix.push(...dimensionArray);\n\n        let arrayName = this.createDataElementFromTypedArray(this.stringToUtf8(name), DataTypes.miINT8); // UINT8 or UTF8 would make more sense, but docs say it should be INT8, note that higher codepoints still work\n        matrix.push(...arrayName);\n\n        let valueType: DataTypes = DataTypes.miDOUBLE;\n        if (!ArrayBuffer.isView(realValues)) {\n            valueType = this.getSmallestDataType(realValues);\n        }\n\n        if (Array.isArray(complexValues) && complexValues.length > 0) {\n            valueType = Math.max(valueType, this.getSmallestDataType(complexValues))\n        }\n\n        if (ArrayBuffer.isView(realValues)) {\n            let realData = this.createDataElementFromTypedArray(realValues);\n            matrix.push(...realData);\n        }\n        else {\n            let realData = this.createDataElementFromNumbers(valueType, realValues);\n            matrix.push(...realData);\n\n            if (Array.isArray(complexValues) && complexValues.length > 0) {\n                let complexData = this.createDataElementFromNumbers(valueType, realValues);\n                matrix.push(...complexData);\n            }\n        }\n\n        // Set length of data of this matrix\n        tag[1] = matrix.reduce((sum, element) => sum + element.byteLength, 0) - 8;\n        return matrix;\n    }\n\n    /**\n     * Creates a matrix containing numbers.\n     * Only accepts 1-D arrays of string\n     * Each string will be saved as a char array with the same length by padding spaces\n     */\n    private createCharArray(name: string, lines: string[]): TypedArray[] {\n        let matrix: TypedArray[] = [];\n        let tag = new Uint32Array(2);\n        tag[0] = DataTypes.miMATRIX;\n        // tag[1] = number of bytes in matrix, to be set at end once all parts are in\n        matrix.push(tag);\n\n        const _flags = 0;\n        const _class = ArrayTypes.mxCHAR_CLASS;\n        let arrayFlags = this.createDataElementFromNumbers(DataTypes.miUINT32, [(_flags << 8) + _class, 0x00000000]); // 0xEFBEADDE\n        matrix.push(...arrayFlags);\n\n        let maxLineLength = lines[0].length;\n        lines.forEach((l) => { if (l.length > maxLineLength) maxLineLength = l.length; });\n\n        let dimensionArray = this.createDataElementFromNumbers(DataTypes.miINT32, [lines.length, maxLineLength]);\n        matrix.push(...dimensionArray);\n\n        let arrayName = this.createDataElementFromTypedArray(this.stringToUtf8(name), DataTypes.miINT8); // UINT8 or UTF8 would make more sense, but docs say it should be INT8, note that higher codepoints still work\n        matrix.push(...arrayName);\n\n        let charData = new Uint8Array(lines.length * maxLineLength);\n        let utf8Lines = lines.map((l) => this.stringToUtf8(l));\n        // Create char data array, columns first as that is how matlab likes it\n        let iChar = 0;\n        for (let iCol = 0; iCol < maxLineLength; iCol++) {\n            for (let iRow = 0; iRow < lines.length; iRow++) {\n                charData[iChar] = iCol < utf8Lines[iRow].length ? utf8Lines[iRow][iCol] : 0x20;\n                iChar++;\n            }\n        }\n\n        let data = this.createDataElementFromTypedArray(charData, DataTypes.miUTF8);\n        matrix.push(...data);\n\n        // Set length of data of this matrix\n        tag[1] = matrix.reduce((sum, element) => sum + element.byteLength, 0) - 8;\n        return matrix;\n    }\n\n    /**\n     * Same as createCharArray, but saves string as UTF16. Not used\n     * Creates a matrix containing numbers.\n     * Only accepts 1-D arrays of string\n     * Each string will be saved as a char array with the same length by padding spaces\n     */\n    private createCharArrayUtf16(name: string, lines: string[]): TypedArray[] {\n        let matrix: TypedArray[] = [];\n        let tag = new Uint32Array(2);\n        tag[0] = DataTypes.miMATRIX;\n        // tag[1] = number of bytes in matrix, to be set at end once all parts are in\n        matrix.push(tag);\n\n        const _flags = 0;\n        const _class = ArrayTypes.mxCHAR_CLASS;\n        let arrayFlags = this.createDataElementFromNumbers(DataTypes.miUINT32, [(_flags << 8) + _class, 0x00000000]); // 0xEFBEADDE\n        matrix.push(...arrayFlags);\n\n        let maxLineLength = lines[0].length;\n        lines.forEach((l) => { if (l.length > maxLineLength) maxLineLength = l.length; });\n\n        let dimensionArray = this.createDataElementFromNumbers(DataTypes.miINT32, [lines.length, maxLineLength]);\n        matrix.push(...dimensionArray);\n\n        let arrayName = this.createDataElementFromTypedArray(this.stringToUtf8(name), DataTypes.miINT8); // UINT8 or UTF8 would make more sense, but docs say it should be INT8, note that higher codepoints still work\n        matrix.push(...arrayName);\n\n        let charData = new Uint16Array(lines.length * maxLineLength);\n        // Create char data array, columns first as that is how matlab likes it\n        let iChar = 0;\n        for (let iCol = 0; iCol < maxLineLength; iCol++) {\n            for (let iRow = 0; iRow < lines.length; iRow++) {\n                charData[iChar] = iCol < lines[iRow].length ? lines[iRow].charCodeAt(iCol) : 0x0020;\n                iChar++;\n            }\n        }\n\n        let data = this.createDataElementFromTypedArray(charData, DataTypes.miUTF16);\n        matrix.push(...data);\n\n        // Set length of data of this matrix\n        tag[1] = matrix.reduce((sum, element) => sum + element.byteLength, 0) - 8;\n        return matrix;\n    }\n\n    /**\n     * Creates a matrix containing cells.\n     * Only accepts 1-D arrays\n     * Converts strings to numeric arrays containg chars\n     * Converts objects to structs\n     * Converts numbers to numeric array\n     */\n    private createCellArray(name: string, values: object[] | number[] | string[]): TypedArray[] {\n        let matrix: TypedArray[] = [];\n        let tag = new Uint32Array(2);\n        tag[0] = DataTypes.miMATRIX;\n        // tag[1] = number of bytes in matrix, to be set at end once all parts are in\n        matrix.push(tag);\n\n        const _flags = 0;\n        const _class = ArrayTypes.mxCELL_CLASS;\n        let arrayFlags = this.createDataElementFromNumbers(DataTypes.miUINT32, [(_flags << 8) + _class, 0x00000000]); // 0xEFBEADDE\n        matrix.push(...arrayFlags);\n\n        let dimensionArray = this.createDataElementFromNumbers(DataTypes.miINT32, [1, values.length]);\n        matrix.push(...dimensionArray);\n\n        let arrayName = this.createDataElementFromTypedArray(this.stringToUtf8(name), DataTypes.miINT8); // UINT8 or UTF8 would make more sense, but docs say it should be INT8, note that higher codepoints still work\n        matrix.push(...arrayName);\n\n        values.forEach((v) => {\n            if (Array.isArray(v))\n                matrix.push(...this.createMatArray(v));\n            else\n                matrix.push(...this.createMatArray([v]));\n        })\n\n        // Set length of data of this matrix\n        tag[1] = matrix.reduce((sum, element) => sum + element.byteLength, 0) - 8;\n        return matrix;\n    }\n\n    /**\n     * Test if all provided objects have the same keys\n     * @param objects \n     */\n    private allObjectsHaveTheSameKeys(objects: object[]): boolean {\n        const keys1 = Object.keys(objects[0]).sort();\n        for (let iObject = 1; iObject < objects.length; iObject++) {\n            const keys2 = Object.keys(objects[iObject]).sort();\n\n            if (keys1.length != keys2.length) {\n                return false;\n            }\n            for (let iKey = 0; iKey < keys1.length; iKey++) {\n                if (keys1[iKey] != keys2[iKey]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private allElementsHaveTheSameType(array: any[]): boolean {\n        function myType(o: any): string {\n            let t = typeof (o);\n            if (t == 'object') t = o.constructor.name;\n            return t;\n        }\n\n        let t = myType(array[0]);\n        for (let i = 1; i < array.length; i++) {\n            if (t != myType(array[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    isTypedArray(arg: any): arg is TypedArray {\n        // Auto determine the data type\n        const supportedTypes = [\n          \"Int8Array\", \n          \"Uint8Array\",\n          \"Int16Array\",\n          \"Uint16Array\",\n          \"Int32Array\",\n          \"Uint32Array\",\n          \"BigInt64Array\",\n          \"BigUint64Array\",\n          \"Float32Array\",\n          \"Float64Array\"\n        ]\n        return supportedTypes.includes(arg.constructor.name)\n    }\n\n    /**\n     * Create a matrix most suited to host the given values \n     * @param values \n     * @returns \n     */\n    private createMatArray(data: any, name: string = \"\", toplevel = false): TypedArray[] {\n        let values: any[] | TypedArray;\n        if (Array.isArray(data) || this.isTypedArray(data)) {\n            values = data;\n        } else {\n            values = [data];\n        }\n\n        let matrix: TypedArray[] = [];\n\n        if (this.isTypedArray(values)) {\n            matrix = this.createNumericArray(name, values)\n        } else if (values.length == 1 && this.isTypedArray(values[0])) {\n            matrix = this.createNumericArray(name, values[0])\n        } else {\n            let allElementsHaveTheSameType = this.allElementsHaveTheSameType(values);\n\n\n            if (allElementsHaveTheSameType && typeof (values[0]) == 'number') {\n                matrix = this.createNumericArray(name, values as number[]);\n            }\n            else if (allElementsHaveTheSameType && typeof (values[0]) == 'string') {\n                if (values.length == 1) {\n                    matrix = this.createCharArray(name, values as string[]);\n                } else {\n                    // A cell array of chars is more likely to be the better fit for an array of strings\n                    matrix = this.createCellArray(name, values);\n                }\n\n            }\n            else if (allElementsHaveTheSameType && values[0].constructor.name == 'Object' && this.allObjectsHaveTheSameKeys(values)) {\n                matrix = this.createStructArray(name, values as object[]);\n            } else {\n                matrix = this.createCellArray(name, values);\n            }\n        }\n\n        if (toplevel && this.compressionEnabled)\n            return this.createZippedArray(matrix);\n        else\n            return matrix;\n    }\n\n    /**\n     * Create a matlab struct array\n     * Only supports 1-D objects\n     * @param data An array of objects of the same type\n     */\n    private createStructArray(name: string, data: { [key: string]: any }[]) {\n        let struct: TypedArray[] = []; let tag = new Uint32Array(2);\n        tag[0] = DataTypes.miMATRIX;\n        // tag[1] = number of bytes in matrix, to be set at end once all parts are in\n        struct.push(tag);\n\n        const _flags = 0;\n        const _class = ArrayTypes.mxSTRUCT_CLASS;\n        let arrayFlags = this.createDataElementFromNumbers(DataTypes.miUINT32, [(_flags << 8) + _class, 0x00000000]); //0xEFBEADDE\n        struct.push(...arrayFlags);\n\n        let dimensionArray = this.createDataElementFromNumbers(DataTypes.miINT32, [1, data.length]);\n        struct.push(...dimensionArray);\n\n        let arrayName = this.createDataElementFromTypedArray(this.stringToUtf8(name), DataTypes.miINT8); // UINT8 or UTF8 would make more sense, but docs say it should be INT8, note that higher codepoints still work\n        struct.push(...arrayName);\n\n        // Determine fieldnames\n        let keys = Object.keys(data[0]);\n\n        // Use the maximum of X characters for the field name in the struct\n        let maxFieldNameLength = Math.max(...keys.map((key) => key.length)) + 1;\n        //if (maxFieldNameLength < 64) maxFieldNameLength = 64;\n\n        let fieldNameLength = this.createDataElementFromNumbers(DataTypes.miINT32, [maxFieldNameLength]);\n        struct.push(...fieldNameLength);\n\n        // Create a single large array with all field names concatenated, each mapped to a maxFieldNameLength bytes int8 array, each name should end with NULL byte\n        let fieldNamesArray = keys.map((key) => this.stringToUtf8(key.padEnd(maxFieldNameLength, \"\\u0000\")))\n        let fieldNames = this.createDataElementFromTypedArray(fieldNamesArray, DataTypes.miINT8);\n        struct.push(...fieldNames);\n\n        // Create a matrix for each key and add it\n        data.forEach((o) => {\n            keys.forEach((key) => {\n                const v = o[key];\n                if (Array.isArray(v))\n                    struct.push(...this.createMatArray(v));\n                else\n                    struct.push(...this.createMatArray([v]));\n            })\n        });\n\n\n        // Set length of data of this struct\n        tag[1] = struct.reduce((sum, element) => sum + element.byteLength, 0) - 8;\n        return struct;\n    }\n\n    private createZippedArray(variable: TypedArray[]) : TypedArray[] {\n        let combined = new Uint8Array(variable.reduce((sum, element) => sum + element.byteLength, 0));\n        let c = 0;\n        for (let v of variable) {\n            combined.set(new Uint8Array(v.buffer), c);\n            c += v.byteLength;\n        }\n\n        const zipped = zlibSync(combined, {level: 6});\n\n        let tag = new Uint32Array(2);\n        tag[0] = DataTypes.miCOMPRESSED;\n        tag[1] = zipped.byteLength;\n\n        return [tag, zipped];\n    }\n\n    public getBlob(): Blob {\n        let blob = new Blob(this.matFile);\n        return blob;\n    }\n\n}"],"mappings":"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","names":["t"]}